<!DOCTYPE html ><html xml:lang="en" lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8"><meta http-equiv="Content-Style-Type" content="text/css"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>NVIDIA Tegra Linux Driver Package Development Guide</title><link rel="Prev" href="l4t_lauterbach_scripts.html" title="Previous"><link rel="Next" href="l4t_toolchain.html" title="Next"><link rel="StyleSheet" href="css/l4t_video_for_linux.css" type="text/css" media="all"><link rel="StyleSheet" href="css/skin.css" type="text/css" media="all"><link rel="StyleSheet" href="css/webworks.css" type="text/css" media="all"><!--[if IE 7]><link rel="StyleSheet" href="css/l4t_video_for_linux_IE7.css" type="text/css" media="all"><![endif]--><link rel="StyleSheet" href="css/print.css" type="text/css" media="print"><script type="text/javascript" src="scripts/common.js"></script><script type="text/javascript" src="scripts/page.js"></script><script type="text/javascript" src="scripts/search-client.js"></script><script type="text/javascript" src="scripts/unidata.js"></script><script type="text/javascript" src="scripts/unibreak.js"></script></head><body id="pj83PcMo3VyEimfFLWyKe_002fA" class="ww_skin_page_body" style="background-position: center center; margin-left: 0pt; margin-right: 10pt" onload="Page.OnLoad('../index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/l4t_video_for_linux.html');"><header><div><table width="100%" align="center" summary=""><tr><td class="Header_Left"><img alt="NVIDIA Tegra" src="images/NVLogo_2D_H.jpg" width="204" height="44" border="0"></td><td class="Header_Right">
           Tegra Linux Driver Package<br>
           Development Guide <br><font size="-1">21.4 Release | July 10, 2015</font></td></tr></table></div><!--     <br clear="all">
 --><hr color="#DEE4F0"><div class="ww_skin_page_toolbar"><!-- Twitter --><!--         --><!-- FaceBook Like --><!--               --><!-- LinkedIn Share --><!--                --><!-- Google +1 --><!--           --><a class="ww_behavior_print ww_skin ww_skin_print" title="Print" href="#">&nbsp;</a></div></header><div id="wwpID0E0TJ0HA" class="Heading_1">V4L2 User Guide for Jetson TK1</div><div id="wwpID0E0SJ0HA" class="Body_Text">This chapter provides information on the use of the MIPI Camera Serial Interface (CSI) on Tegra® K1, using software from the NVIDIA® Tegra® Linux Driver Package (also referred to as L4T).  The MIPI CSI protocol, V4L2 API, Tegra K1 system architecture and method of attaching a CSI camera to Jetson TK1 are outside the scope of this document. </div><div id="wwpID0E0RJ0HA" class="Body_Text">The V4L2 software implementation bypasses the Tegra ISP, and is suitable for use when Tegra ISP support is not required, such as with sensors or input devices that provide data in YUV format.</div><div id="wwpID0E0QJ0HA" class="Body_Text">References to additional resources are provided, but the reader should already be familiar with Tegra K1, and have access to the Tegra Technical Reference Manual (TRM) and other documentation available at the Jetson Embedded Platform portal:</div><div id="wwpID0E0PJ0HA" class="Code"><span class="Hyperlink"><a href="http://developer.nvidia.com/embedded-computing" target="external_window">http://developer.nvidia.com/embedded-computing</a></span></div><div id="wwpID0E0OJ0HA" class="Heading_2">Overview</div><div id="wwpID0E0NJ0HA" class="Body_Text">V4L2 is the second version of Video4Linux or V4L, a video capture and output device API and driver framework in the Linux kernel. It supports many USB webcams, TV tuners, and other devices and is closely integrated with the Linux kernel. For a description of the APIs, see <span class="Hyperlink"><a href="http://linuxtv.org/downloads/v4l-dvb-apis/" target="external_window">Linux Media Infrastructure APIs</a></span>.</div><div id="wwpID0E0MJ0HA" class="Heading_3">soc_camera</div><div id="wwpID0E0LJ0HA" class="Body_Text">soc-camera is a set of drivers and a core module that implement V4L2 functionality on embedded devices. It is a typical video-enabled embedded device: a SoC with a capture interface and video data sources. It includes host drivers like the NVIDIA<span style="vertical-align: super">®</span> Tegra<span style="vertical-align: super">®</span> V4L2 camera driver and client drivers (sensor drivers). </div><div id="wwpID0E0KJ0HA" class="Heading_2">V4L2 on Jetson TK1</div><div id="wwpID0E0JJ0HA" class="Body_Text"><span class="Hyperlink"><a href="http://elinux.org/Jetson_TK1" target="external_window">Jetson TK1</a></span> is a powerful embedded development board for NVIDIA<span style="vertical-align: super">®</span> Tegra<span style="vertical-align: super">®</span> K1 processor. The Tegra K1 processor has a video input interface named VI and camera serial interface named CSI, so it can talk with the external video input sources such as the camera sensor module or other MIPI CSI compatible devices. The VI/CSI of Tegra K1 also has 2 test pattern generators which can generate some data patterns like color bricks for testing purposes.</div><div id="wwpID0E0IJ0HA" class="Body_Text">On the software side, the latest Linux for Tegra (<span class="Hyperlink"><a href="https://developer.nvidia.com/linux-tegra" target="external_window">L4T</a></span>) release (R21.3) provides a Tegra V4L2 camera driver and some sample drivers for both real camera sensors and test pattern generators (TPG). With open source V4L2 and user space tools like <span class="Hyperlink"><a href="http://git.ideasonboard.org/yavta.git" target="external_window">Yavta</a></span>, users can capture data from TPG and real sensors.</div><div id="wwpID0E0HJ0HA" class="Heading_3">Test Pattern Generator</div><div id="wwpID0E0GJ0HA" class="Body_Text">The test pattern generator is a configurable resource introduced to improve hardware verification capability for the Tegra CSI. There are two separate test pattern generators that can be configured to provide for the generation of synthetic image data, which is delivered to the PPA and PPB input FIFOs. The image data is multiplexed into the CSI data patch between lane-merging logic and the data FIFOs.</div><div id="wwpID0E0FJ0HA" class="Body_Text">L4T provides a virtual V4L2 <span class="Code_Char">soc_camera</span> sensor driver for exposing TPG functionality (<span class="Code_Char">soc_camera_platform drive</span>r). It can generate 1280x720 resolution RGBA32 color bricks data. There is no need to rebuild the kernel and the <span class="Code_Char">soc_camera_platform</span> driver is provided as a loadable module.</div><div id="wwpID0E0EJ0HA" class="Heading_5">To verify the TPG</div><div id="wwpID0E0DJ0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Remove the nvhost_vi module, an incompatible non-V4L2 VI driver used for other purposes and outside the scope of this document:</div><div id="wwpID0E0CJ0HA" class="Code">$ sudo rmmod nvhost_vi		</div><div id="wwpID0E0BJ0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Install V4L2 driver modules:</div><div id="wwpID0E0AJ0HA" class="Code">$ sudo modprobe soc_camera_platform</div><div id="wwpID0E06I0HA" class="Code">$ sudo modprobe tegra_camera tpg_mode=2</div><div id="wwpID0E05I0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Use the Yavta application to capture data (other V4L2 applications can be used, if preferred):</div><div id="wwpID0E04I0HA" class="Code">$ ./yavta /dev/video0 -c1 -n1 -s1280x720 -fRGB32 -Ftpg.rgba</div><div id="wwpID0E03I0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Copy over tpg.rgba to host and use ImageMagick to show the picture:</div><div id="wwpID0E02I0HA" class="Code">$ display -size 1280x720 -depth 8 tpg.rgba</div><div id="wwpID0E01I0HA" class="Heading_3">Example Sensor: IMX135</div><div id="wwpID0E0ZI0HA" class="Body_Text">L4T provides a sample V4L2 sensor driver for the Sony IMX135 Bayer sensor.  This driver can be used as a reference in creating a custom V4L2 sensor driver.  NVIDIA does not provide a reference camera module at this time, so the following information is provided for example purposes, assuming you have an IMX135 sensor module connected to Jetson TK1.</div><div id="wwpID0E0YI0HA" class="Body_Text">The driver for IMX135 is neither built into kernel nor built as module. Please try following steps to test IMX135 in L4T on Jetson TK1.</div><div id="wwpID0E0XI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Hardware setup</div><div id="wwpID0E0WI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Jetson TK1</div><div id="wwpID0E0VI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Jetson TK1 adapter board capable of connecting to an IMX135 camera module</div><div id="wwpID0E0UI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Enable IMX135 kernel driver and disable <span class="Code_Char">soc_camera_platform</span></div><div id="wwpID0E0TI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>CONFIG_SOC_CAMERA_IMX135=m</div><div id="wwpID0E0SI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Disable CONFIG_SOC_CAMERA_PLATFORM</div><div id="wwpID0E0RI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Build kernel, flash Jetson TK1, and boot the Linux OS</div><div id="wwpID0E0QI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Use Yavta to capture a frame</div><div id="wwpID0E0PI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Use <span class="Code_Char">raw2bmp</span> to convert raw data to a BMP file</div><div id="wwpID0E0OI0HA" class="Code"><span class="Hyperlink"><a href="https://gitorious.org/omap4-v4l2-camera/yavta/source/5417d27b99b2a147e3a062a24f36fd7a71f49b40:raw2bmp.c" target="external_window">https://gitorious.org/omap4-v4l2-camera/yavta/source/5417d27b99b2a147e3a062a24f36fd7a71f49b40:raw2bmp.c</a></span></div><div id="wwpID0E0NI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Capture color bar test patterns from IMX135TBD</div><div id="wwpID0E0MI0HA" class="Code">$ sudo modprobe imx135_v4l2 test_mode=2</div><div id="wwpID0E0LI0HA" class="Code">$ sudo modprobe tegra_camera</div><div id="wwpID0E0KI0HA" class="Code">$ ./yavta /dev/video0 -c1 -n1 -s1920x1080 -fSRGGB10 -Fimx135.raw</div><div id="wwpID0E0JI0HA" class="Code">$ ./raw2bmp imx135.raw imx135.bmp 1920 1080 16 3</div><div id="wwpID0E0II0HA" class="Heading_3">IMX135 and AR0261 Dual Capture Demo</div><div id="wwpID0E0HI0HA" class="Body_Text">Tegra K1 processor has 2 CSI ports: CSI_A and CSI_B and supports capture from these 2 ports simultaneously. On Jetson TK1, IMX135 connects to CSI_A via 4 data lanes (CIL_A and CIL_B) and AR0261 connects to CSI_B via 1 data lane (CIL_E).</div><div id="wwpID0E0GI0HA" class="Body_Text">L4T kernel source contains drivers for both of these 2 sensors. Try the following steps in L4T on Jetson TK1.</div><div id="wwpID0E0FI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Hardware setup</div><div id="wwpID0E0EI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Jetson TK1</div><div id="wwpID0E0DI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Jetson TK1 adapter board capable of connecting to an IMX135 camera module</div><div id="wwpID0E0CI0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Enable IMX135 kernel driver and disable <span class="Code_Char">soc_camera_platform</span></div><div id="wwpID0E0BI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>CONFIG_SOC_CAMERA_IMX135=m</div><div id="wwpID0E0AI0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>CONFIG_SOC_CAMERA_AR0261=m</div><div id="wwpID0E06H0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Disable CONFIG_SOC_CAMERA_PLATFORM</div><div id="wwpID0E05H0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Build the kernel, flash Jetson TK1, and boot into Ubuntu.</div><div id="wwpID0E04H0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Install the camera modules. Once installed <span class="Code_Char">/dev/video0</span> and <span class="Code_Char">/dev/video1</span> will appear:</div><div id="wwpID0E03H0HA" class="Code">&nbsp;</div><div id="wwpID0E02H0HA" class="Code">$ sudo modprobe tegra_camera</div><div id="wwpID0E01H0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Use Yavta to capture from <span class="Code_Char">/dev/video0</span> and <span class="Code_Char">/dev/video1 </span>at the same time:</div><div id="wwpID0E0ZH0HA" class="Code">$ ./yavta /dev/video0 -c1000 -n4 -s1920x1080 -fSRGGB10 -F/dev/null &amp;</div><div id="wwpID0E0YH0HA" class="Code">$ ./yavta /dev/video1 -c1000 -n4 -s1920x1080 -fSRGGB10 -F/dev/null</div><div id="wwpID0E0XH0HA" class="Heading_2">V4L2 Tegra Driver Overview</div><div id="wwpID0E0WH0HA" class="Body_Text">As V4L2 is a kernel video input framework, Tegra V4L2 stack contains several components.  It controls hardware such as the Tegra VI/CSI hardware controller and external sensors. Additionally, it exports a generic device node named <span class="Code_Char">/dev/video&lt;N&gt;</span> to user space, where <span class="Code_Char">&lt;N&gt;</span> is a numeric value. User space application can use the V4L2 standard API to control real hardware via <span class="Code_Char">/dev/video&lt;N&gt;</span>.</div><div id="wwpID0E0VH0HA" class="Body_Text">This section will focus on Tegra K1-related drivers and code in L4T kernel source.</div><div id="wwpID0E0UH0HA" class="Heading_3">Tegra V4L2 Camera Driver</div><div id="wwpID0E0TH0HA" class="Body_Text">Tegra V4L2 camera driver is a part of soc_camera and acts as a host driver. It directly controls Tegra K1 VI/CSI hardware. Normally users don’t need to modify this driver, but developers should become familiar with it; it may require customization for some use cases.</div><div id="wwpID0E0SH0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Source code</div><div id="wwpID0E0RH0HA" class="Code">drivers/media/platform/soc_camera/Kconfig</div><div id="wwpID0E0QH0HA" class="Code">drivers/media/platform/soc_camera/Makefile</div><div id="wwpID0E0PH0HA" class="Code">drivers/media/platform/soc_camera/tegra_camera/*</div><div id="wwpID0E0OH0HA" class="Code">include/media/tegra_v4l2_camera.h</div><div id="wwpID0E0NH0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Kernel config</div><div id="wwpID0E0MH0HA" class="Code">CONFIG_VIDEO_TEGRA=m</div><div id="wwpID0E0LH0HA" class="List_Continue">The module name is <span class="Code_Char">tegra_camera.ko</span> and it won’t be loaded by default after booting into L4T. There is another driver named <span class="Code_Char">nvhost_vi.ko</span> installed by default and mutually-exclusive with <span class="Code_Char">tegra_camera.ko</span>, so users must remove <span class="Code_Char">nvhost_vi.ko</span> before loading <span class="Code_Char">tegra_camera.ko</span>.</div><div id="wwpID0E0KH0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Input data format</div><div id="wwpID0E0JH0HA" class="List_Continue">Tegra K1 VI/CSI hardware supports 3 major input data format: YUV, RGB and Bayer RAW. However in this driver only the following have been implemented at the time this document was written (please review the driver for current details):</div><div id="wwpID0E0IH0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>RGB888</div><div id="wwpID0E0HH0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>RAW8</div><div id="wwpID0E0GH0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>RAW10</div><div id="wwpID0E0FH0HA" class="Number_Continue"><span class="Strong">Note</span>: YUV formats are also supported by hardware but software support is not present in the driver.  Please refer to the Tegra TRM for details on supported input formats.</div><div id="wwpID0E0EH0HA" class="List_Continue">Study the source code then add new input data formats not listed here.</div><div id="wwpID0E0DH0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>All the formats are listed in <span class="Code_Char">structs tegra_camera_yuv_formats</span>, <span class="Code_Char">tegra_camera_rgb_formats</span> and <span class="Code_Char">tegra_camera_bayer_formats</span> of <span class="Code_Char">drivers/media/platform/soc_camera/tegra_camera/common.c</span></div><div id="wwpID0E0CH0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Add the format into function tegra_camera_get_formats() of  drivers/media/platform/soc_camera/tegra_camera/common.c </div><div id="wwpID0E0BH0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Add the format support into function <span class="Code_Char">vi2_capture_setup_csi_0()</span> and <span class="Code_Char">vi2_capture_setup_csi_1()</span> of <span class="Code_Char">drivers/media/platform/soc_camera/tegra_camera/vi2.c</span></div><div id="wwpID0E0AH0HA" class="Heading_3">Tegra V4L2 Sensor Driver</div><div id="wwpID0E06G0HA" class="Body_Text">V4L2 sensor driver normally is an I2C device driver and in L4T it is also a V4L2 <span class="Code_Char">soc_camera</span> client driver. It has several I2C register tables for different resolutions like 1920x1080, 1280x720 etc. When a user space application opens <span class="Code_Char">/dev/video&lt;N&gt;</span>, the sensor driver will power on the sensor hardware and program it with the register table via I2C.</div><div id="wwpID0E05G0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Real sensor code</div><div id="wwpID0E04G0HA" class="Code">&nbsp;</div><div id="wwpID0E03G0HA" class="Code">drivers/media/i2c/soc_camera/imx135_v4l2.c</div><div id="wwpID0E02G0HA" class="Code">include/media/imx135.h</div><div id="wwpID0E01G0HA" class="Code">drivers/media/i2c/soc_camera/ar0261_v4l2.c</div><div id="wwpID0E0ZG0HA" class="Code">include/media/ar0261.h</div><div id="wwpID0E0YG0HA" class="Code">drivers/media/i2c/soc_camera/Kconfig</div><div id="wwpID0E0XG0HA" class="Code">drivers/media/i2c/soc_camera/Makefile</div><div id="wwpID0E0WG0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Test Pattern Generator virtual sensor driver source code</div><div id="wwpID0E0VG0HA" class="Code">drivers/media/platform/soc_camera/soc_camera_platform.c</div><div id="wwpID0E0UG0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Kernel configs</div><div id="wwpID0E0TG0HA" class="Code">CONFIG_SOC_CAMERA_AR0261</div><div id="wwpID0E0SG0HA" class="Code">CONFIG_SOC_CAMERA_IMX135</div><div id="wwpID0E0RG0HA" class="Code">CONFIG_SOC_CAMERA_PLATFORM</div><div id="wwpID0E0QG0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Power controls</div><div id="wwpID0E0PG0HA" class="List_Continue">Each sensor has its own power on/off sequence, clock settings and other hardware specific operations. L4T sensor driver put these power controls in the sensor driver itself. For more flexible driver design, these power controls need go to board files since each hardware board might have different power controls. Then sensor driver itself can be more generic. Normally power controls include:</div><div id="wwpID0E0OG0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>GPIO for sensor reset, power on or power down</div><div id="wwpID0E0NG0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Regulators for sensor power supply</div><div id="wwpID0E0MG0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Clocks for sensor running like <span class="Code_Char">mclk</span> or the sensor local clock</div><div id="wwpID0E0LG0HA" class="Heading_3">Board File</div><div id="wwpID0E0KG0HA" class="Body_Text">Before fully moving to device tree binding, a board file is the only way to describe platform-specific configurations within the Linux kernel. In L4T R21.3 release most hardware devices use device tree binding but V4L2 <span class="Code_Char">soc_camera</span> still uses a board file approach.</div><div id="wwpID0E0JG0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Source code</div><div id="wwpID0E0IG0HA" class="Code">arch/arm/mach-tegra/board-ardbeg-sensors.c</div><div id="wwpID0E0HG0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>TPG board configs</div><div id="wwpID0E0GG0HA" class="List_Continue"><span class="Code_Char">soc_camera_platform_info</span> defines the data format and resolution which should be matched with our TPG hardware.</div><div id="wwpID0E0FG0HA" class="Code">static struct soc_camera_platform_info ardbeg_soc_camera_info = {</div><div id="wwpID0E0EG0HA" class="Code">        .format_name = "RGB4", </div><div id="wwpID0E0DG0HA" class="Code">        .format_depth = 32,</div><div id="wwpID0E0CG0HA" class="Code">        .format = {</div><div id="wwpID0E0BG0HA" class="Code">                .code = V4L2_MBUS_FMT_RGBA8888_4X8_LE,</div><div id="wwpID0E0AG0HA" class="Code">                .colorspace = V4L2_COLORSPACE_SRGB,</div><div id="wwpID0E06F0HA" class="Code">                .field = V4L2_FIELD_NONE,</div><div id="wwpID0E05F0HA" class="Code">                .width = 1280, </div><div id="wwpID0E04F0HA" class="Code">                .height = 720,</div><div id="wwpID0E03F0HA" class="Code">        },</div><div id="wwpID0E02F0HA" class="Code">        .set_capture = ardbeg_soc_camera_set_capture,</div><div id="wwpID0E01F0HA" class="Code">};</div><div id="wwpID0E0ZF0HA" class="List_Continue"><span class="Code_Char">tegra_camera_platform_data</span> is the most important data struct to describe the sensor connection.  <span class="Code_Char">.port</span> indicates which CSI port the sensor connects to: </div><div id="wwpID0E0YF0HA" class="List_Continue">TEGRA_CAMERA_PORT_CSI_A means the sensor uses CIL_A and CIL_B.</div><div id="wwpID0E0XF0HA" class="List_Continue">TEGRA_CAMERA_PORT_CSI_B means the sensor uses CIL_C and CIL_D.</div><div id="wwpID0E0WF0HA" class="List_Continue">TEGRA_CAMERA_PORT_CSI_C means the sensor uses CIL_E.</div><div id="wwpID0E0VF0HA" class="List_Continue">Tegra K1 internally just has 2 CSI channels (CSI_A and CSI_B). CSI_C is just a software alias to tell the driver that the sensor is using CIL_E.</div><div id="wwpID0E0UF0HA" class="List_Continue">TEGRA_CAMERA_PORT_CSI_A and TEGRA_CAMERA_PORT_CSI_B can support 1, 2 and 4 data lane sensors. TEGRA_CAMERA_PORT_CSI_C can only support 1 lane sensor.</div><div id="wwpID0E0TF0HA" class="Code">static struct tegra_camera_platform_data ardbeg_camera_platform_data = {</div><div id="wwpID0E0SF0HA" class="Code">        .flip_v                 = 0,</div><div id="wwpID0E0RF0HA" class="Code">        .flip_h                 = 0,</div><div id="wwpID0E0QF0HA" class="Code">        .port                   = TEGRA_CAMERA_PORT_CSI_A,</div><div id="wwpID0E0PF0HA" class="Code">        .lanes                  = 4,</div><div id="wwpID0E0OF0HA" class="Code">        .continuous_clk         = 0,</div><div id="wwpID0E0NF0HA" class="Code">};</div><div id="wwpID0E0MF0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>IMX135 board file configs</div><div id="wwpID0E0LF0HA" class="List_Continue">Real sensors don’t require that sensor resolution or data format information be put into the board file like TPG soc_camera_platform driver, because that information is in the sensor driver itself.</div><div id="wwpID0E0KF0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>IMX135 uses the I2C 2 bus and its I2C address is 0x10:</div><div id="wwpID0E0JF0HA" class="Code">static struct i2c_board_info ardbeg_imx135_camera_i2c_device = {</div><div id="wwpID0E0IF0HA" class="Code">        I2C_BOARD_INFO("imx135_v4l2", 0x10),</div><div id="wwpID0E0HF0HA" class="Code">        .platform_data = &amp;ardbeg_imx135_data,</div><div id="wwpID0E0GF0HA" class="Code">};</div><div id="wwpID0E0FF0HA" class="Code">&nbsp;</div><div id="wwpID0E0EF0HA" class="Code">static struct soc_camera_link imx135_iclink = {</div><div id="wwpID0E0DF0HA" class="Code">        .bus_id         = 0, /* This must match the .id of tegra_vi01_device */</div><div id="wwpID0E0CF0HA" class="Code">        .board_info     = &amp;ardbeg_imx135_camera_i2c_device,</div><div id="wwpID0E0BF0HA" class="Code">        .module_name    = "imx135_v4l2",</div><div id="wwpID0E0AF0HA" class="Code">        .i2c_adapter_id = 2,</div><div id="wwpID0E06E0HA" class="Code">        .power          = ardbeg_imx135_power,</div><div id="wwpID0E05E0HA" class="Code">        .priv           = &amp;ardbeg_imx135_camera_platform_data,</div><div id="wwpID0E04E0HA" class="Code">};</div><div id="wwpID0E03E0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Register the IMX135 <span class="Code_Char">soc_camera</span> platform device:</div><div id="wwpID0E02E0HA" class="Code">platform_device_register(&amp;ardbeg_imx135_soc_camera_device);</div><div id="wwpID0E01E0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>AR0261 board file configs:</div><div id="wwpID0E0ZE0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>AR0261 connects to port CSI_C via 1 data lane.</div><div id="wwpID0E0YE0HA" class="Code">static struct tegra_camera_platform_data ardbeg_ar0261_camera_platform_data = {</div><div id="wwpID0E0XE0HA" class="Code">        .flip_v                 = 0,</div><div id="wwpID0E0WE0HA" class="Code">        .flip_h                 = 0,</div><div id="wwpID0E0VE0HA" class="Code">        .port                   = TEGRA_CAMERA_PORT_CSI_C,</div><div id="wwpID0E0UE0HA" class="Code">        .lanes                  = 1,</div><div id="wwpID0E0TE0HA" class="Code">        .continuous_clk         = 0,</div><div id="wwpID0E0SE0HA" class="Code">};</div><div id="wwpID0E0RE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>AR0261 uses the I2C 2 bus and it’s I2C address is 0x36:</div><div id="wwpID0E0QE0HA" class="Code">static struct i2c_board_info ardbeg_ar0261_camera_i2c_device = {</div><div id="wwpID0E0PE0HA" class="Code">        I2C_BOARD_INFO("ar0261_v4l2", 0x36),</div><div id="wwpID0E0OE0HA" class="Code">        .platform_data = &amp;ardbeg_ar0261_data,</div><div id="wwpID0E0NE0HA" class="Code">};</div><div id="wwpID0E0ME0HA" class="Code">static struct soc_camera_link ar0261_iclink = {</div><div id="wwpID0E0LE0HA" class="Code">        .bus_id         = 1, /* This must match the .id of tegra_vi01_device */</div><div id="wwpID0E0KE0HA" class="Code">        .board_info     = &amp;ardbeg_ar0261_camera_i2c_device,</div><div id="wwpID0E0JE0HA" class="Code">        .module_name    = "ar0261_v4l2",</div><div id="wwpID0E0IE0HA" class="Code">        .i2c_adapter_id = 2,</div><div id="wwpID0E0HE0HA" class="Code">        .power          = ardbeg_ar0261_power,</div><div id="wwpID0E0GE0HA" class="Code">        .priv           = &amp;ardbeg_ar0261_camera_platform_data,</div><div id="wwpID0E0FE0HA" class="Code">};</div><div id="wwpID0E0EE0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Register the AR0261 <span class="Code_Char">soc_camera</span> platform device:</div><div id="wwpID0E0DE0HA" class="Code">platform_device_register(&amp;ardbeg_ar0261_soc_camera_device);</div><div id="wwpID0E0CE0HA" class="Heading_3">Device Tree File</div><div id="wwpID0E0BE0HA" class="Body_Text">Device tree still provides regulator information required by the V4L2 sensor driver. Both the IMX135 and AR0261 sensor drivers use 3 regulators: <span class="Code_Char">vana</span>, <span class="Code_Char">vdig</span> and <span class="Code_Char">vif</span>. They are defined in: <span class="Code_Char">arch/arm/boot/dts/tegra124-platforms/tegra124-jetson_tk1-pmic-pm375-0000-c00-00.dtsi</span>.</div><div id="wwpID0E0AE0HA" class="Body_Text">IMX135 needs 2 extra regulators that are also defined in the same file.</div><div id="wwpID0E06D0HA" class="Heading_2">How to Write and Integrate a Sensor Driver</div><div id="wwpID0E05D0HA" class="Body_Text">Developers can write their own sensor driver for their specific device. Sensor drivers usually have very similar structures but different I2C register tables. Modification of the board file and the device tree file is required for different boards.</div><div id="wwpID0E04D0HA" class="Heading_3">Sensor Driver Development</div><div id="wwpID0E03D0HA" class="Body_Text">The IMX135 and AR0261 sensor drivers are a good start point for writing a new sensor driver. The following steps are recommended for developing a new driver:</div><div id="wwpID0E02D0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Import new I2C register tables</div><div id="wwpID0E01D0HA" class="List_Continue">Sensor vendors will provide I2C register settings as tables, which should be added to sensor driver. The following struct is a good example:</div><div id="wwpID0E0ZD0HA" class="Code">static struct imx135_reg *mode_table[] = {</div><div id="wwpID0E0YD0HA" class="Code">        [IMX135_MODE_4208X3120] = mode_4208x3120,</div><div id="wwpID0E0XD0HA" class="Code">        [IMX135_MODE_1920X1080] = mode_1920x1080,</div><div id="wwpID0E0WD0HA" class="Code">        [IMX135_MODE_1280X720]  = mode_1280x720,</div><div id="wwpID0E0VD0HA" class="Code">        [IMX135_MODE_2616X1472]  = mode_2616x1472,</div><div id="wwpID0E0UD0HA" class="Code">        [IMX135_MODE_3896X2192]  = mode_3896x2192,</div><div id="wwpID0E0TD0HA" class="Code">        [IMX135_MODE_2104X1560]  = mode_2104x1560,</div><div id="wwpID0E0SD0HA" class="Code">};</div><div id="wwpID0E0RD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Power controls</div><div id="wwpID0E0QD0HA" class="List_Continue">Different boards have different sensor power controls. It is better put those power controls into a board file. But it is simpler to implement them in a sensor driver. Please take a look at <span class="Code_Char">imx135_power_on()</span> and imx135_power_off().</div><div id="wwpID0E0PD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>soc_camera and the I2C interface</div><div id="wwpID0E0OD0HA" class="List_Continue">The sensor driver implements <span class="Code_Char">soc_camera ops</span> functions as well as the I2C device probing/removing functions. Normally these are quite similar across different sensor drivers -- just reuse them in your driver and use <span class="Code_Char">imx135_v4l2.c</span> as an example.</div><div id="wwpID0E0ND0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>KConfig and Makefile</div><div id="wwpID0E0MD0HA" class="List_Continue">Add a <span class="Code_Char">SOC_CAMERA_IMX135</span> entry into the <span class="Code_Char">Kconfig</span> and <span class="Code_Char">Makefile</span> files.</div><div id="wwpID0E0LD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Kernel module parameters</div><div id="wwpID0E0KD0HA" class="List_Continue">Building a sensor driver as a module is beneficial for validating different module parameters. In the IMX135 sensor driver, a parameter for <span class="Code_Char">test_mode</span> is passed when loading the module. Because IMX135 has a color bar test pattern generator inside, using this parameter can ask IMX135 to send out color bar data for testing and bypass those lens or focuser settings.</div><div id="wwpID0E0JD0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Header file include/media/sensor.h</div><div id="wwpID0E0ID0HA" class="List_Continue">This header contains some information for non-V4L2 NVIDIA camera stacks. The following structs can be reused if necessary:</div><div id="wwpID0E0HD0HA" class="Code">struct imx135_power_rail {</div><div id="wwpID0E0GD0HA" class="Code">        struct regulator *dvdd;</div><div id="wwpID0E0FD0HA" class="Code">        struct regulator *avdd;</div><div id="wwpID0E0ED0HA" class="Code">        struct regulator *iovdd;</div><div id="wwpID0E0DD0HA" class="Code">        struct regulator *ext_reg1;</div><div id="wwpID0E0CD0HA" class="Code">        struct regulator *ext_reg2;</div><div id="wwpID0E0BD0HA" class="Code">};</div><div id="wwpID0E0AD0HA" class="Code">&nbsp;</div><div id="wwpID0E06C0HA" class="Code">struct imx135_platform_data {</div><div id="wwpID0E05C0HA" class="Code">        struct imx135_flash_control flash_cap;</div><div id="wwpID0E04C0HA" class="Code">        const char *mclk_name; /* NULL for default default_mclk */</div><div id="wwpID0E03C0HA" class="Code">        unsigned int cam1_gpio;</div><div id="wwpID0E02C0HA" class="Code">        unsigned int reset_gpio;</div><div id="wwpID0E01C0HA" class="Code">        unsigned int af_gpio;</div><div id="wwpID0E0ZC0HA" class="Code">        bool ext_reg;</div><div id="wwpID0E0YC0HA" class="Code">        int (*power_on)(struct imx135_power_rail *pw);</div><div id="wwpID0E0XC0HA" class="Code">        int (*power_off)(struct imx135_power_rail *pw);</div><div id="wwpID0E0WC0HA" class="Code">};</div><div id="wwpID0E0VC0HA" class="Heading_3">Board File and Device Tree File Updates</div><div id="wwpID0E0UC0HA" class="Body_Text">A new project or new hardware board might have a new board file such as board-ardbeg*.c for Jetson TK1. If so, the new board file should include those settings for sensor drivers. Follow this template in the board file and replace “SENSOR” with your sensor name:</div><div id="wwpID0E0TC0HA" class="Code">#if IS_ENABLED(CONFIG_SOC_CAMERA_SENSOR)</div><div id="wwpID0E0SC0HA" class="Code">static int ardbeg_sensor_power(struct device *dev, int enable)</div><div id="wwpID0E0RC0HA" class="Code">{</div><div id="wwpID0E0QC0HA" class="Code">        return 0;</div><div id="wwpID0E0PC0HA" class="Code">}</div><div id="wwpID0E0OC0HA" class="Code">// NOTE: power controls can go here instead of sensor driver itself.</div><div id="wwpID0E0NC0HA" class="Code">&nbsp;</div><div id="wwpID0E0MC0HA" class="Code">struct sensor_platform_data ardbeg_sensor_data;</div><div id="wwpID0E0LC0HA" class="Code">&nbsp;</div><div id="wwpID0E0KC0HA" class="Code">static struct i2c_board_info ardbeg_sensor_camera_i2c_device = {</div><div id="wwpID0E0JC0HA" class="Code">        I2C_BOARD_INFO("sensor_v4l2_driver_name", sensor_i2c_address),</div><div id="wwpID0E0IC0HA" class="Code">        // sensor_v4l2_driver_name should match the sensor driver’s module name</div><div id="wwpID0E0HC0HA" class="Code">        .platform_data = &amp;ardbeg_sensor_data,</div><div id="wwpID0E0GC0HA" class="Code">};</div><div id="wwpID0E0FC0HA" class="Code">&nbsp;</div><div id="wwpID0E0EC0HA" class="Code">static struct tegra_camera_platform_data ardbeg_sensor_camera_platform_data = {</div><div id="wwpID0E0DC0HA" class="Code">        .flip_v                 = 0,</div><div id="wwpID0E0CC0HA" class="Code">        .flip_h                 = 0,</div><div id="wwpID0E0BC0HA" class="Code">        .port                   = TEGRA_CAMERA_PORT_CSI_X_for_sensor,</div><div id="wwpID0E0AC0HA" class="Code">        .lanes                  = number_of_sensor_data_lanes,</div><div id="wwpID0E06B0HA" class="Code">        .continuous_clk         = 0,</div><div id="wwpID0E05B0HA" class="Code">};</div><div id="wwpID0E04B0HA" class="Code">&nbsp;</div><div id="wwpID0E03B0HA" class="Code">static struct soc_camera_link sensor_iclink = {</div><div id="wwpID0E02B0HA" class="Code">        .bus_id         = 0, /* This must match the .id of tegra_vi01_device */</div><div id="wwpID0E01B0HA" class="Code">        .board_info     = &amp;ardbeg_sensor_camera_i2c_device,</div><div id="wwpID0E0ZB0HA" class="Code">        .module_name    = "sensor_v4l2_driver_name",</div><div id="wwpID0E0YB0HA" class="Code">        .i2c_adapter_id = sensor_i2c_bus_number,</div><div id="wwpID0E0XB0HA" class="Code">        .power          = ardbeg_sensor_power,</div><div id="wwpID0E0WB0HA" class="Code">        .priv           = &amp;ardbeg_sensor_camera_platform_data,</div><div id="wwpID0E0VB0HA" class="Code">};</div><div id="wwpID0E0UB0HA" class="Code">&nbsp;</div><div id="wwpID0E0TB0HA" class="Code">static struct platform_device ardbeg_sensor_soc_camera_device = {</div><div id="wwpID0E0SB0HA" class="Code">        .name   = "soc-camera-pdrv",</div><div id="wwpID0E0RB0HA" class="Code">        .id     = 0,</div><div id="wwpID0E0QB0HA" class="Code">        .dev    = {</div><div id="wwpID0E0PB0HA" class="Code">                .platform_data = &amp;sensor_iclink,</div><div id="wwpID0E0OB0HA" class="Code">        },</div><div id="wwpID0E0NB0HA" class="Code">};</div><div id="wwpID0E0MB0HA" class="Code">#endif</div><div id="wwpID0E0LB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Register the platform device in <span class="Code_Char">ardbeg_camera_init()</span>:</div><div id="wwpID0E0KB0HA" class="Code">&nbsp;</div><div id="wwpID0E0JB0HA" class="Code">#if IS_ENABLED(CONFIG_SOC_CAMERA_SENSOR)</div><div id="wwpID0E0IB0HA" class="Code">        platform_device_register(&amp;ardbeg_sensor_soc_camera_device);</div><div id="wwpID0E0HB0HA" class="Code">#endif</div><div id="wwpID0E0GB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Device tree update:</div><div id="wwpID0E0FB0HA" class="List_Continue">Find the new device tree file for the new board and update regulator information appropriate to the hardware configuration of the new board. A good example to look at is:</div><div id="wwpID0E0EB0HA" class="Code">arch/arm/boot/dts/tegra124-platforms/tegra124-jetson_tk1-pmic-pm375-0000-c00-00.dtsi</div><div id="wwpID0E0DB0HA" class="Heading_3">Troubleshooting</div><div id="wwpID0E0CB0HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>I2C transaction timeout error</div><div id="wwpID0E0BB0HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>I2C information is wrong</div><div id="wwpID0E0AB0HA" class="List_Continue_2">Check the sensor I2C bus number and the sensor I2C device address in the board file.</div><div id="wwpID0E6HA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Sensor power control sequence is wrong</div><div id="wwpID0E5HA" class="List_Continue_2">Check sensor MCLK setting.</div><div id="wwpID0E4HA" class="List_Continue_2">Check regulator operations.</div><div id="wwpID0E3HA" class="List_Continue_2">Check GPIO settings.</div><div id="wwpID0E2HA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Sync point timeout without error</div><div id="wwpID0E1HA" class="List_Continue">This means Tegra VI/CSI doesn’t receive any data but no error occurs. Make sure the sensor is powered on and streaming data correctly before debugging the Tegra driver.</div><div id="wwpID0EZHA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Change settle time value to see if there if some error shows up. These registers must be configured with the right values to get data from the sensor.</div><div id="wwpID0EYHA" class="Code_Indent">TC_VI_REG_WT(cam, TEGRA_CSI_PHY_CILA_CONTROL0, 0x9);</div><div id="wwpID0EXHA" class="Code_Indent">TC_VI_REG_WT(cam, TEGRA_CSI_PHY_CILB_CONTROL0, 0x9);</div><div id="wwpID0EWHA" class="List_Continue_2">or</div><div id="wwpID0EVHA" class="Code_Indent">TC_VI_REG_WT(cam, TEGRA_CSI_PHY_CILC_CONTROL0, 0x9);</div><div id="wwpID0EUHA" class="Code_Indent">TC_VI_REG_WT(cam, TEGRA_CSI_PHY_CILD_CONTROL0, 0x9);</div><div id="wwpID0ETHA" class="List_Continue_2">or</div><div id="wwpID0ESHA" class="Code_Indent">TC_VI_REG_WT(cam, TEGRA_CSI_PHY_CILE_CONTROL0, 0x9);</div><div id="wwpID0ERHA" class="List_Bullet_2"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Make sure that <span class="Code_Char">CILA/B</span> or <span class="Code_Char">CILC/D</span> or <span class="Code_Char">CILE</span> are not in deep power mode (DPD). DPD mode is normally disabled in sensor power on function. Please use <span class="Code_Char">tegra_io_dpd_disable()</span> of <span class="Code_Char">imx135_v4l2.c</span> as an example.</div><div id="wwpID0EQHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Sync point timeout with error</div><div id="wwpID0EPHA" class="List_Continue">Capture the error message and look it up in <span class="Emphasis">Tegra K1 TRM</span> for further debugging.</div><div id="wwpID0EOHA" class="Heading_2">Resources</div><div id="wwpID0ENHA" class="Body_Text">Good resources for V4L integration are:</div><div id="wwpID0EMHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Kernel documentation located in:</div><div id="wwpID0ELHA" class="Code">Documentation/video4linux/</div><div id="wwpID0EKHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Linux TV website:</div><div id="wwpID0EJHA" class="Code"><span class="Hyperlink"><a href="http://www.linuxtv.org/" target="external_window">http://www.linuxtv.org/</a></span></div><div id="wwpID0EIHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>soc-camera slides:</div><div id="wwpID0EHHA" class="Code"><span class="Hyperlink"><a href="http://elinux.org/images/f/f2/Soc-camera.pdf" target="external_window">http://elinux.org/images/f/f2/Soc-camera.pdf</a></span></div><div id="wwpID0EGHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Yavta user space V4L2 tool</div><div id="wwpID0EFHA" class="Code"><span class="Hyperlink"><a href="http://git.ideasonboard.org/yavta.git" target="external_window">http://git.ideasonboard.org/yavta.git</a></span></div><div id="wwpID0EEHA" class="List_Bullet"><span class="WebWorks_Number" style="width: 18pt"><span>•</span></span>Jetson Embedded Platform page</div><div id="wwpID0EDHA" class="Code"><span class="Hyperlink"><a href="http://developer.nvidia.com/embedded-computing" target="external_window">http://developer.nvidia.com/embedded-computing</a></span></div><div id="wwpID0EBHA" class="Code">&nbsp;</div><footer><!-- Related Topics --><!--                --><!-- Disqus --><!--        --><!-- Google Translation --><!--                    --><br><hr color="#DEE4F0"><table width="90%" align="center" summary=""><tr><td class="Footer_Left"><font color="gray"><b><br>
        Copyright © 2011-2015 by NVIDIA Corporation.
          All rights reserved.
        </font></td><td class="Footer_Right"><font color="gray">
           PG_06076-R21<br>
        Revised: 10 Jul 2015
        </font></td></tr></table></footer></body></html>